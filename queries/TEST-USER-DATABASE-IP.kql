// ============================================================================
// TEST 1: CORRELACIÃ“N - Enriquecer AUDIT logs con USER/DATABASE/IP
// ============================================================================
// Los logs AUDIT no incluyen user/database/IP directamente.
// Necesitamos correlacionar con el log CONNECTION previo del mismo processId.
// ============================================================================

// Paso 1: Extraer informaciÃ³n de conexiones (user, database, IP por processId)
let sessionInfo = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)  // Ampliar ventana para capturar conexiones antiguas
| where message contains "connection authorized" or message contains "connection received"
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    DatabaseName = extract(@"database=([^\s,]+)", 1, message),
    // Capturar host (IP o hostname) y puerto
    ClientHost = extract(@"host=([^\s]+)", 1, message),
    ClientPort = extract(@"port=(\d+)", 1, message)
| where isnotempty(UserName) or isnotempty(ClientHost)
| summarize 
    User = any(UserName),
    Database = any(DatabaseName),
    SourceHost = any(ClientHost),
    SourcePort = any(ClientPort),
    ConnectionTime = min(EventProcessedUtcTime)
    by processId, LogicalServerName;

// Paso 2: Unir logs AUDIT con informaciÃ³n de sesiÃ³n
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(1h)
| extend 
    MessageType = case(
        message contains "connection authorized", "ðŸ” CONNECTION",
        message contains "connection received", "ðŸ”Œ CONN_RECEIVED",
        message contains "AUDIT:", "ðŸ“‹ AUDIT",
        message contains "authentication failed", "âŒ AUTH_FAILED",
        message contains "disconnection", "ðŸ‘‹ DISCONNECT",
        "â“ OTHER"
    ),
    HasAudit = iff(message contains "AUDIT:", "âœ… AUDIT", "âŒ No AUDIT"),
    // ExtracciÃ³n directa (solo funciona en CONNECTION logs)
    DirectUser = extract(@"user=([^\s,]+)", 1, message),
    DirectDatabase = extract(@"database=([^\s,]+)", 1, message),
    DirectHost = extract(@"host=([^\s]+)", 1, message),
    DirectPort = extract(@"port=(\d+)", 1, message)
| join kind=leftouter sessionInfo on processId, LogicalServerName
| extend 
    // Usar info directa si existe, si no, usar correlacionada
    FinalUser = iff(isnotempty(DirectUser), DirectUser, User),
    FinalDatabase = iff(isnotempty(DirectDatabase), DirectDatabase, Database),
    FinalHost = iff(isnotempty(DirectHost), DirectHost, SourceHost),
    FinalPort = iff(isnotempty(DirectPort), DirectPort, SourcePort)
| take 50
| extend 
    UserDisplay = iff(isempty(FinalUser), "âŒ No disponible", FinalUser),
    DatabaseDisplay = iff(isempty(FinalDatabase), "âŒ No disponible", FinalDatabase),
    HostDisplay = iff(isempty(FinalHost), "âŒ No disponible", FinalHost),
    ConnectionInfo = iff(isnotempty(FinalHost) and isnotempty(FinalPort), strcat(FinalHost, ":", FinalPort), 
                     iff(isnotempty(FinalHost), FinalHost, "âŒ No disponible"))
| project 
    EventProcessedUtcTime,
    MessageType,
    HasAudit,
    User = UserDisplay,
    Database = DatabaseDisplay,
    Host = HostDisplay,
    Port = FinalPort,
    Connection = ConnectionInfo,
    backend_type,
    processId,
    message
| order by EventProcessedUtcTime desc;


// ============================================================================
// TEST: Resumen de cobertura (% de logs con User/Database/IP)
// ============================================================================

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(1h)
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    DatabaseName = extract(@"database=([^\s,]+)", 1, message),
    ClientHost = extract(@"host=([^\s]+)", 1, message),
    MessageType = case(
        message contains "connection authorized", "CONNECTION",
        message contains "AUDIT:", "AUDIT",
        message contains "authentication failed", "AUTH_FAILED",
        "OTHER"
    )
| summarize 
    TotalLogs = count(),
    WithUser = countif(isnotempty(UserName)),
    WithDatabase = countif(isnotempty(DatabaseName)),
    WithHost = countif(isnotempty(ClientHost))
    by MessageType
| extend 
    UserCoverage = strcat(round((todouble(WithUser) / TotalLogs) * 100, 1), "%"),
    DatabaseCoverage = strcat(round((todouble(WithDatabase) / TotalLogs) * 100, 1), "%"),
    HostCoverage = strcat(round((todouble(WithHost) / TotalLogs) * 100, 1), "%")
| project 
    MessageType, 
    TotalLogs, 
    UserCoverage, 
    DatabaseCoverage, 
    HostCoverage
| order by TotalLogs desc;


// ============================================================================
// TEST: TOP USUARIOS con mÃ¡s actividad (Ãºltimas 6h)
// ============================================================================

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(6h)
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    DatabaseName = extract(@"database=([^\s,]+)", 1, message)
| where isnotempty(UserName)
| summarize 
    TotalActivity = count(),
    Databases = make_set(DatabaseName),
    FirstActivity = min(EventProcessedUtcTime),
    LastActivity = max(EventProcessedUtcTime)
    by UserName, LogicalServerName
| top 10 by TotalActivity desc
| project 
    Usuario = UserName,
    Servidor = LogicalServerName,
    ActividadTotal = TotalActivity,
    BasesDeDatos = Databases,
    PrimeraActividad = FirstActivity,
    UltimaActividad = LastActivity;


// ============================================================================
// TEST: Detectar posibles Hosts/IPs sospechosos (si disponible)
// ============================================================================

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| extend ClientHost = extract(@"host=([^\s]+)", 1, message)
| where isnotempty(ClientHost)
| summarize 
    TotalConnections = count(),
    UniqueUsers = dcount(extract(@"user=([^\s,]+)", 1, message)),
    Errors = countif(errorLevel in ("ERROR", "FATAL")),
    FirstSeen = min(EventProcessedUtcTime),
    LastSeen = max(EventProcessedUtcTime)
    by ClientHost, LogicalServerName
| extend 
    ErrorRate = round((todouble(Errors) / TotalConnections) * 100, 2),
    Riesgo = case(
        round((todouble(Errors) / TotalConnections) * 100, 2) > 20, "ðŸ”´ ALTO",
        round((todouble(Errors) / TotalConnections) * 100, 2) > 5, "ðŸŸ  MEDIO",
        "ðŸŸ¢ BAJO"
    )
| top 10 by TotalConnections desc
| project 
    Host = ClientHost,
    Servidor = LogicalServerName,
    Conexiones = TotalConnections,
    UsuariosUnicos = UniqueUsers,
    Errores = Errors,
    ErrorRate,
    Riesgo,
    PrimeraConexion = FirstSeen,
    UltimaConexion = LastSeen
| order by TotalConnections desc;
