// ============================================================================
// UNIFIED ANOMALY DETECTION - PostgreSQL Real-Time Intelligence
// ============================================================================
// Complete anomaly detection system with ML & security patterns
// Unified version: Setup + Dashboard RTI + Advanced Alerts
// ============================================================================

// ============================================================================
// SECTION 1: SETUP - INFRASTRUCTURE CREATION
// ============================================================================

// ----------------------------------------------------------------------------
// 1.1 Main Table: Activity Metrics with Temporal Dimensions
// ----------------------------------------------------------------------------

.create table postgres_activity_metrics (
    Timestamp: datetime,
    ServerName: string,
    HourOfDay: int,              // 0-23 for hourly patterns
    DayOfWeek: int,              // 0=Sun, 1=Mon, ..., 6=Sat
    ActivityCount: long,
    AuditLogs: long,
    Errors: long,
    Connections: long,
    UniqueUsers: long,           // Distinct active users
    SelectOps: long,             // Read operations
    WriteOps: long,              // INSERT/UPDATE/DELETE
    DDLOps: long,                // CREATE/DROP/ALTER
    PrivilegeOps: long           // GRANT/REVOKE (escalation alerts)
)


// ----------------------------------------------------------------------------
// 1.2 Activity Metrics Transformation Function
// ----------------------------------------------------------------------------

.create-or-alter function postgres_activity_metrics_transform() {
    bronze_pssql_alllogs_nometrics
    | where category == "PostgreSQLLogs"
    | extend 
        HourOfDay = toint(hourofday(EventProcessedUtcTime)),
        DayOfWeek = toint(dayofweek(EventProcessedUtcTime) / 1d),
        UserName = extract(@"user=([^\s,]+)", 1, message)
    | summarize 
        ActivityCount = count(),
        AuditLogs = countif(message contains "AUDIT:"),
        Errors = countif(errorLevel in ("ERROR", "FATAL", "PANIC")),
        Connections = countif(message contains "connection authorized"),
        UniqueUsers = dcount(UserName),
        SelectOps = countif(message has_any ("SELECT", "COPY", ",READ,")),
        WriteOps = countif(message has_any ("INSERT", "UPDATE", "DELETE", ",WRITE,")),
        DDLOps = countif(message has_any ("CREATE", "DROP", "ALTER TABLE", "ALTER INDEX")),
        PrivilegeOps = countif(message has_any ("GRANT", "REVOKE", "ALTER ROLE", "CREATE ROLE"))
        by ServerName = LogicalServerName, 
           Timestamp = bin(EventProcessedUtcTime, 5m),
           HourOfDay = toint(hourofday(EventProcessedUtcTime)),
           DayOfWeek = toint(dayofweek(EventProcessedUtcTime) / 1d)
    | project Timestamp, ServerName, HourOfDay, DayOfWeek, 
              ActivityCount, AuditLogs, Errors, Connections,
              UniqueUsers, SelectOps, WriteOps, DDLOps, PrivilegeOps
}


// ----------------------------------------------------------------------------
// 1.3 Update Policy for Automatic Updates
// ----------------------------------------------------------------------------

.alter table postgres_activity_metrics policy update 
@'[{"IsEnabled": true, "Source": "bronze_pssql_alllogs_nometrics", "Query": "postgres_activity_metrics_transform()", "IsTransactional": false, "PropagateIngestionProperties": false}]'


// ----------------------------------------------------------------------------
// 1.4 Initial Historical Data Load (30 days for ML baseline)
// ----------------------------------------------------------------------------

.set-or-append postgres_activity_metrics <|
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(30d)
    | where category == "PostgreSQLLogs"
    | extend 
        HourOfDay = toint(hourofday(EventProcessedUtcTime)),
        DayOfWeek = toint(dayofweek(EventProcessedUtcTime) / 1d),
        UserName = extract(@"user=([^\s,]+)", 1, message)
    | summarize 
        ActivityCount = count(),
        AuditLogs = countif(message contains "AUDIT:"),
        Errors = countif(errorLevel in ("ERROR", "FATAL", "PANIC")),
        Connections = countif(message contains "connection authorized"),
        UniqueUsers = dcount(UserName),
        SelectOps = countif(message has_any ("SELECT", "COPY", ",READ,")),
        WriteOps = countif(message has_any ("INSERT", "UPDATE", "DELETE", ",WRITE,")),
        DDLOps = countif(message has_any ("CREATE", "DROP", "ALTER TABLE")),
        PrivilegeOps = countif(message has_any ("GRANT", "REVOKE", "ALTER ROLE"))
        by ServerName = LogicalServerName, 
           Timestamp = bin(EventProcessedUtcTime, 5m),
           HourOfDay = toint(hourofday(EventProcessedUtcTime)),
           DayOfWeek = toint(dayofweek(EventProcessedUtcTime) / 1d)
    | project Timestamp, ServerName, HourOfDay, DayOfWeek,
              ActivityCount, AuditLogs, Errors, Connections,
              UniqueUsers, SelectOps, WriteOps, DDLOps, PrivilegeOps


// ----------------------------------------------------------------------------
// 1.5 Error Metrics Table
// ----------------------------------------------------------------------------

.create table postgres_error_metrics (
    Timestamp: datetime,
    ServerName: string,
    ErrorRate: long,
    ErrorTypes: string
)


.create-or-alter function postgres_error_metrics_transform() {
    bronze_pssql_alllogs_nometrics
    | where category == "PostgreSQLLogs"
    | where errorLevel in ("ERROR", "FATAL", "PANIC") or (sqlerrcode != "00000" and sqlerrcode != "")
    | extend ErrorCategory = case(
        message contains "authentication" or message contains "password", "Authentication",
        message contains "permission denied", "Permission",
        message contains "connection", "Connection",
        "Other"
    )
    | summarize 
        ErrorRate = count(),
        ErrorTypes = strcat_array(make_set(ErrorCategory), ", ")
        by ServerName = LogicalServerName, Timestamp = bin(EventProcessedUtcTime, 1m)
    | project Timestamp, ServerName, ErrorRate, ErrorTypes
}


.alter table postgres_error_metrics policy update 
@'[{"IsEnabled": true, "Source": "bronze_pssql_alllogs_nometrics", "Query": "postgres_error_metrics_transform()", "IsTransactional": false, "PropagateIngestionProperties": false}]'


.set-or-append postgres_error_metrics <|
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(30d)
    | where category == "PostgreSQLLogs"
    | where errorLevel in ("ERROR", "FATAL", "PANIC") or (sqlerrcode != "00000" and sqlerrcode != "")
    | extend ErrorCategory = case(
        message contains "authentication" or message contains "password", "Authentication",
        message contains "permission denied", "Permission",
        message contains "connection", "Connection",
        "Other"
    )
    | summarize 
        ErrorRate = count(),
        ErrorTypes = strcat_array(make_set(ErrorCategory), ", ")
        by ServerName = LogicalServerName, Timestamp = bin(EventProcessedUtcTime, 1m)
    | project Timestamp, ServerName, ErrorRate, ErrorTypes;


// ----------------------------------------------------------------------------
// 1.6 User Metrics Table
// ----------------------------------------------------------------------------

.create table postgres_user_metrics (
    Timestamp: datetime,
    UserName: string,
    ServerName: string,
    QueryCount: long,
    SelectQueries: long,
    DestructiveOps: long
)


.create-or-alter function postgres_user_metrics_transform() {
    let sessionInfo = 
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized" or message contains "connection received"
    | extend UserName = extract(@"user=([^\s,]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName) by processId, LogicalServerName;
    
    bronze_pssql_alllogs_nometrics
    | where category == "PostgreSQLLogs"
    | where message contains "AUDIT:"
    | join kind=leftouter sessionInfo on processId, LogicalServerName
    | where isnotempty(User)
    | extend
        IsSelect = message has_any ("SELECT", "COPY"),
        IsDestructive = message has_any ("DELETE", "UPDATE", "TRUNCATE", "DROP")
    | summarize 
        QueryCount = count(),
        SelectQueries = countif(IsSelect),
        DestructiveOps = countif(IsDestructive)
        by UserName = User, ServerName = LogicalServerName, Timestamp = bin(EventProcessedUtcTime, 1h)
    | project Timestamp, UserName, ServerName, QueryCount, SelectQueries, DestructiveOps
}


.alter table postgres_user_metrics policy update 
@'[{"IsEnabled": true, "Source": "bronze_pssql_alllogs_nometrics", "Query": "postgres_user_metrics_transform()", "IsTransactional": false, "PropagateIngestionProperties": false}]'


.set-or-append postgres_user_metrics <|
    postgres_user_metrics_transform()
    | where Timestamp >= ago(7d);


// ============================================================================
// SECTION 2: REAL-TIME ANOMALY QUERIES
// ============================================================================

// ----------------------------------------------------------------------------
// 2.1 ANOMALY: Mass Data Exfiltration
// ----------------------------------------------------------------------------

let suspiciousDataAccess = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(5m)
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where message has_any ("SELECT", "COPY", "pg_dump")
| where backend_type == "client backend"
| extend 
    AuditOperation = extract(@"AUDIT: SESSION,\d+,\d+,([A-Z]+),", 1, message),
    AuditStatement = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message),
    TableName = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    QueryText = trim('"', extract(@",,,([^<]+)<", 1, message)),
    ProcessSession = strcat(LogicalServerName, "-", processId),
    DirectUser = extract(@"user=([^\s,]+)", 1, message),
    DirectDatabase = extract(@"database=([^\s,]+)", 1, message),
    DirectHost = extract(@"host=([^\s]+)", 1, message)
| where AuditOperation == "READ" or AuditStatement == "SELECT"
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized" or message contains "connection received"
    | extend 
        UserName = extract(@"user=([^\s,]+)", 1, message),
        DatabaseName = extract(@"database=([^\s,]+)", 1, message),
        ClientHost = extract(@"host=([^\s]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName), Database = any(DatabaseName), SourceHost = any(ClientHost)
        by processId, LogicalServerName
) on processId, LogicalServerName
| extend
    FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN")),
    FinalDatabase = iff(isnotempty(DirectDatabase), DirectDatabase, iff(isnotempty(Database), Database, "UNKNOWN")),
    FinalHost = iff(isnotempty(DirectHost), DirectHost, iff(isnotempty(SourceHost), SourceHost, "UNKNOWN"))
| where FinalUser != "azuresu"
| summarize 
    SelectCount = count(),
    FirstSeen = min(EventProcessedUtcTime),
    LastSeen = max(EventProcessedUtcTime),
    TablesAccessed = make_set(TableName, 10),
    SampleQueries = make_set(QueryText, 3),
    User = any(FinalUser),
    Database = any(FinalDatabase),
    SourceHost = any(FinalHost)
    by ProcessSession, LogicalServerName, backend_type, processId
| where SelectCount > 15
| extend 
    AnomalyType = "Potential Data Exfiltration",
    Severity = case(
        SelectCount > 50, "CRITICAL",
        SelectCount > 30, "HIGH",
        "MEDIUM"
    )
| project 
    TimeGenerated = LastSeen,
    AnomalyType,
    Severity,
    ServerName = LogicalServerName,
    User,
    Database,
    SourceHost,
    BackendType = backend_type,
    ProcessID = processId,
    SelectCount,
    TimeWindow = strcat(format_datetime(FirstSeen, 'HH:mm:ss'), " - ", format_datetime(LastSeen, 'HH:mm:ss')),
    TablesAccessed = strcat_array(TablesAccessed, ", "),
    SampleQueries = strcat_array(SampleQueries, " ||| ");

suspiciousDataAccess


// ----------------------------------------------------------------------------
// Mass Destructive Operations
// ----------------------------------------------------------------------------

let destructiveOperations = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(10m)
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where message has_any ("DELETE", "UPDATE", "TRUNCATE", "DROP TABLE", "DROP DATABASE")
| extend 
    AuditOperation = extract(@"AUDIT: SESSION,\d+,\d+,([A-Z]+),", 1, message),
    AuditStatement = trim(' ', extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message)),
    TableAffected = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    QueryText = trim('"', extract(@",,,([^<]+)<", 1, message)),
    DirectUser = extract(@"user=([^\s,]+)", 1, message),
    DirectDatabase = extract(@"database=([^\s,]+)", 1, message),
    DirectHost = extract(@"host=([^\s]+)", 1, message)
// Filter destructive operations by message or statement
| where message has_any ("DELETE", "UPDATE", "TRUNCATE", "DROP")
| where AuditOperation == "WRITE" or AuditStatement has_any ("DELETE", "UPDATE", "TRUNCATE", "DROP")
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized" or message contains "connection received"
    | extend 
        UserName = extract(@"user=([^\s,]+)", 1, message),
        DatabaseName = extract(@"database=([^\s,]+)", 1, message),
        ClientHost = extract(@"host=([^\s]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName), Database = any(DatabaseName), SourceHost = any(ClientHost)
        by processId, LogicalServerName
) on processId, LogicalServerName
| extend
    FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN")),
    FinalDatabase = iff(isnotempty(DirectDatabase), DirectDatabase, iff(isnotempty(Database), Database, "UNKNOWN")),
    FinalHost = iff(isnotempty(DirectHost), DirectHost, iff(isnotempty(SourceHost), SourceHost, "UNKNOWN"))
// Filter out Azure maintenance users BEFORE aggregation
| where FinalUser !in ("azuresu", "azure_maintenance", "UNKNOWN")
| summarize 
    OperationCount = count(),
    Operations = make_set(AuditStatement),
    TablesAffected = make_set(TableAffected),
    FirstOccurrence = min(EventProcessedUtcTime),
    LastOccurrence = max(EventProcessedUtcTime),
    SampleMessages = make_set(QueryText, 3),
    User = any(FinalUser),
    Database = any(FinalDatabase),
    SourceHost = any(FinalHost)
    by LogicalServerName, backend_type, bin(EventProcessedUtcTime, 2m)
| where OperationCount > 5
| where backend_type == "client backend"
| extend 
    AnomalyType = "Mass Destructive Operations",
    Severity = case(
        OperationCount > 20, "CRITICAL",
        OperationCount > 10, "HIGH",
        "MEDIUM"
    )
| project 
    TimeGenerated = LastOccurrence,
    AnomalyType,
    Severity,
    ServerName = LogicalServerName,
    User,
    Database,
    SourceHost,
    BackendType = backend_type,
    OperationCount,
    Operations,
    TablesAffected,
    TimeWindow = strcat(FirstOccurrence, " to ", LastOccurrence),
    SampleMessages;

destructiveOperations


// ----------------------------------------------------------------------------
// Critical Error Spike
// ----------------------------------------------------------------------------

let errorSpike = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(15m)
| where category == "PostgreSQLLogs"
| where errorLevel in ("ERROR", "FATAL", "PANIC")
    or (sqlerrcode != "00000" and sqlerrcode != "")
| extend 
    ErrorCategory = case(
        message contains "authentication" or message contains "password", "Authentication Failure",
        message contains "permission denied" or message contains "access denied", "Permission Denied",
        message contains "connection" or message contains "timeout", "Connection Error",
        sqlerrcode startswith "28", "Authorization Error",
        sqlerrcode startswith "42", "Permission Error",
        sqlerrcode startswith "08", "Connection Error",
        sqlerrcode startswith "53", "Resource Error",
        sqlerrcode startswith "57", "Operator Intervention",
        "Other Error"
    ),
    DirectUser = extract(@"user=([^\s,]+)", 1, message),
    DirectDatabase = extract(@"database=([^\s,]+)", 1, message),
    DirectHost = extract(@"host=([^\s]+)", 1, message)
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized" or message contains "connection received"
    | extend 
        UserName = extract(@"user=([^\s,]+)", 1, message),
        DatabaseName = extract(@"database=([^\s,]+)", 1, message),
        ClientHost = extract(@"host=([^\s]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName), Database = any(DatabaseName), SourceHost = any(ClientHost)
        by processId, LogicalServerName
) on processId, LogicalServerName
| extend
    FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN")),
    FinalDatabase = iff(isnotempty(DirectDatabase), DirectDatabase, iff(isnotempty(Database), Database, "UNKNOWN")),
    FinalHost = iff(isnotempty(DirectHost), DirectHost, iff(isnotempty(SourceHost), SourceHost, "UNKNOWN"))
| summarize 
    ErrorCount = count(),
    ErrorTypes = make_set(ErrorCategory),
    ErrorCodes = make_set(sqlerrcode),
    FirstError = min(EventProcessedUtcTime),
    LastError = max(EventProcessedUtcTime),
    SampleErrors = make_set(message, 3),
    User = any(FinalUser),
    Database = any(FinalDatabase),
    SourceHost = any(FinalHost)
    by LogicalServerName, backend_type, bin(EventProcessedUtcTime, 1m)
| where ErrorCount > 3
| extend 
    AnomalyType = "Critical Error Spike",
    Severity = case(
        ErrorCount > 15, "CRITICAL",
        ErrorCount > 8, "HIGH",
        "MEDIUM"
    )
| project 
    TimeGenerated = LastError,
    AnomalyType,
    Severity,
    ServerName = LogicalServerName,
    User,
    Database,
    SourceHost,
    BackendType = backend_type,
    ErrorCount,
    ErrorTypes,
    ErrorCodes,
    TimeWindow = strcat(FirstError, " to ", LastError),
    SampleErrors
| order by ErrorCount desc;

errorSpike


// ----------------------------------------------------------------------------
// Privilege Escalation
// ----------------------------------------------------------------------------
// IMPORTANT NOTE: Azure PostgreSQL does NOT generate AUDIT logs for GRANT/REVOKE by default.
// This query detects privilege modification attempts based on:
// - AUDIT logs if pgaudit is configured with "ROLE" class
// - WARNING/ERROR messages when there are issues with roles/grants
// - Any log mentioning privilege operations
// The threshold is 0 (any occurrence) because these are critical security events.
// ----------------------------------------------------------------------------

let privilegeEscalation = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where category == "PostgreSQLLogs"
// Search in ALL message types (AUDIT, LOG, WARNING, ERROR)
| where message has_any ("GRANT", "REVOKE", "ALTER ROLE", "CREATE ROLE", "DROP ROLE")
// Exclude internal Azure operations
| where message !contains "azure_maintenance" and message !contains "azuresu"
| where backend_type == "client backend" or isempty(backend_type)
| extend 
    PrivilegeOp = case(
        message contains "CREATE ROLE", "CREATE ROLE",
        message contains "DROP ROLE", "DROP ROLE",
        message contains "GRANT", "GRANT",
        message contains "REVOKE", "REVOKE",
        message contains "ALTER ROLE", "ALTER ROLE",
        "ROLE_RELATED"
    ),
    QueryText = substring(message, 0, 200),
    DirectUser = extract(@"user=([^\s,]+)", 1, message),
    LogType = errorLevel
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized" or message contains "connection received"
    | extend UserName = extract(@"user=([^\s,]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName) by processId, LogicalServerName
) on processId, LogicalServerName
| extend FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN"))
// Filter out Azure system users
| where FinalUser !in ("azuresu", "azure_maintenance", "UNKNOWN")
| summarize 
    PrivilegeOpsCount = count(),
    Operations = make_set(PrivilegeOp),
    LogTypes = make_set(LogType),
    FirstOp = min(EventProcessedUtcTime),
    LastOp = max(EventProcessedUtcTime),
    SampleQueries = make_set(QueryText, 3),
    User = any(FinalUser)
    by LogicalServerName, bin(EventProcessedUtcTime, 1h)
// ANY privilege operation is critical (threshold = 0)
| where PrivilegeOpsCount > 0
| extend 
    AnomalyType = "Privilege Escalation",
    Severity = case(
        PrivilegeOpsCount > 5, "CRITICAL",
        PrivilegeOpsCount > 3, "HIGH",
        "MEDIUM"
    )
| project 
    TimeGenerated = LastOp,
    AnomalyType,
    Severity,
    ServerName = LogicalServerName,
    User,
    PrivilegeOpsCount,
    Operations,
    LogTypes,
    TimeWindow = strcat(FirstOp, " to ", LastOp),
    SampleQueries;

privilegeEscalation


// ----------------------------------------------------------------------------
// Cross-Schema Reconnaissance
// ----------------------------------------------------------------------------

let crossSchemaRecon = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(15m)
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where backend_type == "client backend"
| extend 
    SchemaAccessed = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^\.]+)\.", 1, message),
    TableAccessed = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    DirectUser = extract(@"user=([^\s,]+)", 1, message)
| where isnotempty(SchemaAccessed) or isnotempty(TableAccessed)
| extend SchemaName = iff(isnotempty(SchemaAccessed), SchemaAccessed, 
    extract(@"^([^\.]+)\.", 1, TableAccessed))
| where isnotempty(SchemaName) and SchemaName !in ("pg_catalog", "information_schema", "")
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized"
    | extend UserName = extract(@"user=([^\s,]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName) by processId, LogicalServerName
) on processId, LogicalServerName
| extend FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN"))
| where FinalUser != "azuresu"
| summarize 
    SchemasAccessed = dcount(SchemaName),
    SchemaList = make_set(SchemaName),
    TablesAccessed = dcount(TableAccessed),
    FirstAccess = min(EventProcessedUtcTime),
    LastAccess = max(EventProcessedUtcTime),
    User = any(FinalUser)
    by LogicalServerName, processId, bin(EventProcessedUtcTime, 10m)
| where SchemasAccessed > 4
| extend 
    AnomalyType = "Cross-Schema Reconnaissance",
    Severity = case(
        SchemasAccessed > 8, "CRITICAL",
        SchemasAccessed > 5, "HIGH",
        "MEDIUM"
    )
| project 
    TimeGenerated = LastAccess,
    AnomalyType,
    Severity,
    ServerName = LogicalServerName,
    User,
    SchemasAccessed,
    SchemaList = strcat_array(SchemaList, ", "),
    TablesAccessed,
    TimeWindow = strcat(FirstAccess, " to ", LastAccess);

crossSchemaRecon


// ----------------------------------------------------------------------------
// Deep System Schema Enumeration
// ----------------------------------------------------------------------------

let deepSchemaEnum = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(10m)
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where backend_type == "client backend"
// First filter by message to capture all queries to system tables
| where message has_any ("pg_catalog", "information_schema", "pg_tables", "pg_class", 
        "pg_attribute", "pg_proc", "pg_type", "pg_constraint", "pg_roles", "pg_indexes",
        "table_constraints", "table_privileges", "routines")
| extend QueryText = coalesce(
    trim('"', extract(@",,,([^<]+)<", 1, message)),
    extract(@"statement: (.+)$", 1, message),
    message
)
| extend 
    SystemTable = case(
        QueryText contains "pg_tables", "pg_tables",
        QueryText contains "pg_class", "pg_class",
        QueryText contains "pg_attribute", "pg_attribute",
        QueryText contains "pg_proc", "pg_proc",
        QueryText contains "pg_type", "pg_type",
        QueryText contains "pg_constraint", "pg_constraint",
        QueryText contains "pg_roles", "pg_roles",
        QueryText contains "pg_indexes", "pg_indexes",
        QueryText contains "information_schema.tables", "info_tables",
        QueryText contains "information_schema.columns", "info_columns",
        QueryText contains "information_schema.routines", "info_routines",
        "other_system"
    ),
    DirectUser = extract(@"user=([^\s,]+)", 1, message)
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized"
    | extend UserName = extract(@"user=([^\s,]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName) by processId, LogicalServerName
) on processId, LogicalServerName
| extend FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN"))
| where FinalUser != "azuresu"
| summarize 
    SystemTableQueries = count(),
    TablesScanned = make_set(SystemTable),
    UniqueSystemTables = dcount(SystemTable),
    FirstQuery = min(EventProcessedUtcTime),
    LastQuery = max(EventProcessedUtcTime),
    SampleQueries = make_set(QueryText, 3),
    User = any(FinalUser)
    by LogicalServerName, processId, bin(EventProcessedUtcTime, 5m)
| where SystemTableQueries > 10
| extend 
    AnomalyType = "Deep Schema Enumeration",
    Severity = case(
        SystemTableQueries > 30, "CRITICAL",
        SystemTableQueries > 15, "HIGH",
        "MEDIUM"
    ),
    RiskLevel = iff(UniqueSystemTables > 5, "üî¥ HIGH - Multi-table scan", "üü† MEDIUM")
| project 
    TimeGenerated = LastQuery,
    AnomalyType,
    Severity,
    RiskLevel,
    ServerName = LogicalServerName,
    User,
    SystemTableQueries,
    UniqueSystemTables,
    TablesScanned = strcat_array(TablesScanned, ", "),
    TimeWindow = strcat(FirstQuery, " to ", LastQuery);

deepSchemaEnum


// ----------------------------------------------------------------------------
// 2.7 ANOMALY: Brute Force Authentication Attempts
// ----------------------------------------------------------------------------

let bruteForceScan = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where category == "PostgreSQLLogs"
| where message contains "authentication failed" 
    or message contains "password authentication failed"
    or sqlerrcode == "28P01"
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    ClientHost = extract(@"host=([^\s]+)", 1, message),
    DatabaseName = extract(@"database=([^\s,]+)", 1, message)
| where isnotempty(ClientHost) or isnotempty(UserName)
| summarize 
    FailedAttempts = count(),
    FirstAttempt = min(EventProcessedUtcTime),
    LastAttempt = max(EventProcessedUtcTime),
    Users = make_set(UserName, 10),
    Databases = make_set(DatabaseName, 5)
    by ClientHost
| where FailedAttempts > 5
| extend 
    AnomalyType = "Brute Force Authentication",
    Severity = case(
        FailedAttempts > 20, "CRITICAL",
        FailedAttempts > 10, "HIGH",
        "MEDIUM"
    )
| project 
    TimeGenerated = LastAttempt,
    AnomalyType,
    Severity,
    ServerName = "Multiple",
    SourceHost = ClientHost,
    FailedAttempts,
    Users = strcat_array(Users, ", "),
    Databases = strcat_array(Databases, ", "),
    TimeWindow = strcat(format_datetime(FirstAttempt, 'HH:mm:ss'), " - ", format_datetime(LastAttempt, 'HH:mm:ss'));

bruteForceScan


// ----------------------------------------------------------------------------
// 2.8 ANOMALY: ML Anomaly Detection - Baseline Deviation
// ----------------------------------------------------------------------------

let mlAnomalyDetection = 
postgres_activity_metrics
| where Timestamp >= ago(7d)
| where isnotempty(ServerName)
| make-series ActivitySeries = sum(ActivityCount) default=0 
    on Timestamp step 5m 
    by ServerName
| extend (anomalies, score, baseline) = 
    series_decompose_anomalies(ActivitySeries, 1.5, -1, 'linefit')
| mv-expand Timestamp to typeof(datetime), 
    ActivitySeries to typeof(long), 
    anomalies to typeof(int), 
    score to typeof(double), 
    baseline to typeof(double)
| where anomalies != 0
| where Timestamp >= ago(1h)
| extend 
    AnomalyType = "ML Baseline Deviation",
    AnomalyDirection = iff(anomalies > 0, "üìà Above Normal", "üìâ Below Normal"),
    Severity = case(
        abs(score) > 3.0, "CRITICAL",
        abs(score) > 2.0, "HIGH",
        "MEDIUM"
    )
| project 
    TimeGenerated = Timestamp,
    AnomalyType,
    AnomalyDirection,
    Severity,
    ServerName,
    ActivityCount = ActivitySeries,
    ExpectedBaseline = round(baseline, 0),
    DeviationScore = round(score, 2)
| order by abs(DeviationScore) desc
| take 20;

mlAnomalyDetection


// ============================================================================
// SECTION 3: MAIN DASHBOARD - ALL ANOMALIES
// ============================================================================

union
    (suspiciousDataAccess),
    (destructiveOperations),
    (errorSpike),
    (privilegeEscalation),
    (crossSchemaRecon),
    (deepSchemaEnum),
    (bruteForceScan)
| order by TimeGenerated desc
| take 100;


// ============================================================================
// SECTION 4: OPERATIONAL METRICS DASHBOARDS
// ============================================================================

// ----------------------------------------------------------------------------
// 4.1 General Activity by Server (last hour)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(1h)
| where isnotempty(LogicalServerName) and trim(" ", LogicalServerName) != ""
| summarize 
    TotalEvents = count(),
    Errors = countif(errorLevel in ("ERROR", "FATAL", "PANIC")),
    Warnings = countif(errorLevel == "WARNING"),
    AuditLogs = countif(message contains "AUDIT:")
    by LogicalServerName, bin(EventProcessedUtcTime, 2m)
| render timechart


// ----------------------------------------------------------------------------
// 4.2 Distribution of AUDIT Operation Types (last 6h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(6h)
| where message contains "AUDIT:"
| extend AuditStatement = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message)
| where isnotempty(AuditStatement)
| summarize Count = count() by AuditStatement
| order by Count desc
| take 10
| render piechart;


// ----------------------------------------------------------------------------
// 4.3 Top 15 Most Accessed Tables
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(6h)
| where message contains "AUDIT:"
| extend 
    ObjectType = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    ObjectName = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,[^,]*,([^,<]*)", 1, message)
| where isnotempty(ObjectName) and ObjectName != ""
| summarize 
    AccessCount = count(),
    LastAccess = max(EventProcessedUtcTime),
    ObjectTypes = make_set(ObjectType, 5)
    by ObjectName, LogicalServerName
| extend ObjectTypesDisplay = strcat_array(ObjectTypes, ", ")
| top 15 by AccessCount desc
| project ObjectName, ObjectTypesDisplay, LogicalServerName, AccessCount, LastAccess;


// ----------------------------------------------------------------------------
// 4.4 Timeline of AUDIT Operations by Type (last hour)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(1h)
| where message contains "AUDIT:"
| extend OperationType = case(
    message contains ",READ," or message contains ",SELECT,", "SELECT",
    message contains ",WRITE," or message contains ",UPDATE,", "WRITE",
    message contains ",DELETE,", "DELETE",
    message contains ",INSERT,", "INSERT",
    message contains ",DDL,", "DDL",
    message contains ",MISC,", "MISC",
    "OTHER"
)
| summarize Count = count() by OperationType, bin(EventProcessedUtcTime, 2m)
| render timechart;


// ----------------------------------------------------------------------------
// 4.5 Errors by Category (last 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where errorLevel in ("ERROR", "FATAL", "PANIC")
| extend ErrorCategory = case(
    message contains "authentication", "Auth Errors",
    message contains "permission", "Permission Errors",
    message contains "connection", "Connection Errors",
    sqlerrcode startswith "28", "Auth Errors",
    sqlerrcode startswith "42", "Permission Errors",
    sqlerrcode startswith "08", "Connection Errors",
    sqlerrcode startswith "53", "Resource Errors",
    "Other Errors"
)
| summarize Count = count() by ErrorCategory, bin(EventProcessedUtcTime, 30m)
| render areachart;


// ----------------------------------------------------------------------------
// 4.6 Activity by Backend Type (last hour)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(1h)
| where message contains "AUDIT:"
| summarize 
    TotalLogs = count(),
    Errors = countif(errorLevel in ("ERROR", "FATAL"))
    by backend_type, bin(EventProcessedUtcTime, 5m)
| render timechart;


// ----------------------------------------------------------------------------
// 4.7 TOP 10 USERS by Activity (last 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| extend UserName = trim('"', extract(@"user=([^\s,]+)", 1, message))
| where isnotempty(UserName)
| summarize 
    TotalActivity = count(),
    AuditLogs = countif(message contains "AUDIT:"),
    Connections = countif(message contains "connection authorized"),
    Errors = countif(errorLevel in ("ERROR", "FATAL")),
    Databases = dcount(trim('"', extract(@"database=([^\s,]+)", 1, message))),
    LastActivity = max(EventProcessedUtcTime)
    by UserName
| top 10 by TotalActivity desc
| project UserName, TotalActivity, AuditLogs, Connections, Errors, Databases, LastActivity;


// ----------------------------------------------------------------------------
// 4.8 TOP 10 HOSTS/IPs by Connections (last 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| extend 
    ClientHost = extract(@"host=([^\s]+)", 1, message),
    UserName = extract(@"user=([^\s,]+)", 1, message)
| where isnotempty(ClientHost)
| summarize 
    TotalConnections = count(),
    UniqueUsers = dcount(UserName),
    Users = make_set(UserName, 10),
    Errors = countif(errorLevel in ("ERROR", "FATAL")),
    FirstSeen = min(EventProcessedUtcTime),
    LastSeen = max(EventProcessedUtcTime)
    by ClientHost
| extend 
    UsersDisplay = strcat_array(Users, ", "),
    ErrorRate = round((todouble(Errors) / TotalConnections) * 100, 2),
    Risk = case(
        round((todouble(Errors) / TotalConnections) * 100, 2) > 20, "HIGH",
        round((todouble(Errors) / TotalConnections) * 100, 2) > 5, "MEDIUM",
        "LOW"
    )
| top 10 by TotalConnections desc
| project ClientHost, TotalConnections, UniqueUsers, UsersDisplay, Errors, ErrorRate, Risk, FirstSeen, LastSeen;


// ----------------------------------------------------------------------------
// 4.9 Heat Map User + Database (last 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where message contains "AUDIT:" or message contains "connection authorized"
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    DatabaseName = extract(@"database=([^\s,]+)", 1, message)
| where isnotempty(UserName) and isnotempty(DatabaseName)
| summarize 
    ActivityCount = count(),
    AuditLogs = countif(message contains "AUDIT:"),
    LastActivity = max(EventProcessedUtcTime)
    by UserName, DatabaseName
| where ActivityCount > 10
| order by ActivityCount desc
| take 50
| project UserName, DatabaseName, ActivityCount, AuditLogs, LastActivity;


// ----------------------------------------------------------------------------
// 4.10 Authentication Failures by User/Host (last 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where message contains "authentication failed" 
    or message contains "password authentication failed"
    or sqlerrcode == "28P01"
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    ClientHost = extract(@"host=([^\s]+)", 1, message),
    DatabaseName = extract(@"database=([^\s,]+)", 1, message)
| summarize 
    FailedAttempts = count(),
    FirstAttempt = min(EventProcessedUtcTime),
    LastAttempt = max(EventProcessedUtcTime),
    Databases = make_set(DatabaseName)
    by UserName, ClientHost
| extend 
    ThreatLevel = case(
        FailedAttempts > 20, "CRITICAL",
        FailedAttempts > 10, "HIGH",
        FailedAttempts > 5, "MEDIUM",
        "LOW"
    )
| order by FailedAttempts desc
| take 20
| project UserName, ClientHost, FailedAttempts, ThreatLevel, Databases, FirstAttempt, LastAttempt;


// ----------------------------------------------------------------------------
// 4.11 Top Error Codes (last 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where sqlerrcode != "00000" and sqlerrcode != ""
| summarize 
    Count = count(),
    LastOccurrence = max(EventProcessedUtcTime)
    by sqlerrcode, errorLevel
| order by Count desc
| take 15
| extend ErrorDescription = case(
    sqlerrcode startswith "28", "Auth/Authorization",
    sqlerrcode startswith "42", "Syntax/Permission",
    sqlerrcode startswith "08", "Connection Exception",
    sqlerrcode startswith "53", "Insufficient Resources",
    sqlerrcode startswith "57", "Operator Intervention",
    sqlerrcode startswith "23", "Integrity Violation",
    "Other"
)
| project sqlerrcode, ErrorDescription, errorLevel, Count, LastOccurrence;


// ============================================================================
// SECTION 5: MONITORING AND VALIDATION QUERIES
// ============================================================================

// ----------------------------------------------------------------------------
// 5.1 Check Metrics Tables Status
// ----------------------------------------------------------------------------

// View latest records from postgres_activity_metrics
postgres_activity_metrics
| order by Timestamp desc
| take 20;

// Statistics by server
postgres_activity_metrics
| where Timestamp >= ago(24h)
| summarize 
    Records = count(),
    AvgActivity = avg(ActivityCount),
    MaxActivity = max(ActivityCount),
    AvgErrors = avg(Errors),
    AvgUniqueUsers = avg(UniqueUsers)
    by ServerName;


// ----------------------------------------------------------------------------
// 5.2 Check Data Freshness
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| summarize 
    LastEvent = max(EventProcessedUtcTime),
    FirstEvent = min(EventProcessedUtcTime),
    TotalEvents = count(),
    TimeRange = datetime_diff('day', max(EventProcessedUtcTime), min(EventProcessedUtcTime))
| extend 
    Status = iff(datetime_diff('minute', now(), LastEvent) < 5, "‚úÖ Fresh data", "‚ö†Ô∏è Stale data"),
    LatencyMinutes = datetime_diff('minute', now(), LastEvent);


// ----------------------------------------------------------------------------
// 5.3 AUDIT Logs Coverage
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(1h)
| summarize 
    TotalLogs = count(),
    AuditLogs = countif(message contains "AUDIT:"),
    ErrorLogs = countif(errorLevel in ("ERROR", "FATAL", "PANIC")),
    WarningLogs = countif(errorLevel == "WARNING")
    by LogicalServerName
| extend 
    AuditCoverage = round((todouble(AuditLogs) / TotalLogs) * 100, 2),
    ErrorRate = round((todouble(ErrorLogs) / TotalLogs) * 100, 2);


// ----------------------------------------------------------------------------
// 5.4 Backend Types Distribution
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| summarize Count = count() by backend_type
| order by Count desc;


// ============================================================================
// SECTION 6: TROUBLESHOOTING & MAINTENANCE
// ============================================================================

// ----------------------------------------------------------------------------
// View Active Update Policies
// ----------------------------------------------------------------------------
.show table postgres_activity_metrics policy update
.show table postgres_error_metrics policy update
.show table postgres_user_metrics policy update


// ----------------------------------------------------------------------------
// View Ingestion Failures
// ----------------------------------------------------------------------------
.show ingestion failures
| where Table in ("postgres_activity_metrics", "postgres_error_metrics", "postgres_user_metrics")
| order by FailedOn desc
| take 20;


// ----------------------------------------------------------------------------
// Force Manual Refresh (if needed)
// ----------------------------------------------------------------------------
// .refresh table postgres_activity_metrics
// .refresh table postgres_error_metrics
// .refresh table postgres_user_metrics


// ============================================================================
// SECTION 7: CLEANUP (OPTIONAL - Only to restart from scratch)
// ============================================================================

// ‚ö†Ô∏è UNCOMMENT ONLY IF YOU WANT TO DELETE EVERYTHING AND START OVER

// .drop table postgres_activity_metrics ifexists
// .drop table postgres_error_metrics ifexists
// .drop table postgres_user_metrics ifexists
// .drop function postgres_activity_metrics_transform ifexists
// .drop function postgres_error_metrics_transform ifexists
// .drop function postgres_user_metrics_transform ifexists


// ============================================================================
// END OF UNIFIED SETUP - PostgreSQL Anomaly Detection
// ============================================================================
