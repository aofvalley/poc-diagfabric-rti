// ============================================================================
// KQL QUERIES FINALES - PostgreSQL Anomaly Detection
// ============================================================================
// Versi√≥n con CORRELACI√ìN User/Database/Host
// Los logs AUDIT no contienen user/database/host directamente
// Se correlacionan con logs CONNECTION usando processId + LogicalServerName
// ============================================================================

// ============================================================================
// HELPER: Tabla de sesiones (User/Database/Host por processId)
// ============================================================================
// Esta tabla se usa para enriquecer logs AUDIT con contexto de usuario
let sessionInfo = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where message contains "connection authorized" or message contains "connection received"
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    DatabaseName = extract(@"database=([^\s,]+)", 1, message),
    ClientHost = extract(@"host=([^\s]+)", 1, message)
| where isnotempty(UserName)
| summarize User = any(UserName), Database = any(DatabaseName), SourceHost = any(ClientHost)
    by processId, LogicalServerName;

// ============================================================================
// ANOMAL√çA 1: Extracci√≥n Masiva de Datos (High SELECT Activity)
// ============================================================================
// VERSI√ìN STANDALONE para dashboards RTI (sessionInfo como subquery inline)

let suspiciousDataAccess = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(5m)
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where message has_any ("SELECT", "COPY", "pg_dump")
| where backend_type == "client backend"  // ‚ö†Ô∏è SOLO usuarios reales, NO workers internos
| extend 
    AuditOperation = extract(@"AUDIT: SESSION,\d+,\d+,([A-Z]+),", 1, message),
    AuditStatement = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message),
    TableName = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    QueryText = trim('"', extract(@",,,([^<]+)<", 1, message)),
    ProcessSession = strcat(LogicalServerName, "-", processId),
    // Extracci√≥n directa del mensaje AUDIT (algunos logs incluyen user/database/host)
    DirectUser = extract(@"user=([^\s,]+)", 1, message),
    DirectDatabase = extract(@"database=([^\s,]+)", 1, message),
    DirectHost = extract(@"host=([^\s]+)", 1, message)
| where AuditOperation == "READ" or AuditStatement == "SELECT"
// Correlaci√≥n con sessionInfo (inline) para obtener User/Database/Host
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized" or message contains "connection received"
    | extend 
        UserName = extract(@"user=([^\s,]+)", 1, message),
        DatabaseName = extract(@"database=([^\s,]+)", 1, message),
        ClientHost = extract(@"host=([^\s]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName), Database = any(DatabaseName), SourceHost = any(ClientHost)
        by processId, LogicalServerName
) on processId, LogicalServerName
| extend
    // Priorizar extracci√≥n directa, luego sessionInfo, finalmente "UNKNOWN"
    FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN")),
    FinalDatabase = iff(isnotempty(DirectDatabase), DirectDatabase, iff(isnotempty(Database), Database, "UNKNOWN")),
    FinalHost = iff(isnotempty(DirectHost), DirectHost, iff(isnotempty(SourceHost), SourceHost, "UNKNOWN"))
| where FinalUser != "azuresu"  // Filtrar usuario de monitoreo de la plataforma
| summarize 
    SelectCount = count(),
    FirstSeen = min(EventProcessedUtcTime),
    LastSeen = max(EventProcessedUtcTime),
    TablesAccessed = make_set(TableName, 10),  // Lista de tablas accedidas
    SampleQueries = make_set(QueryText, 3),   // Primeras 3 queries (cambio: make_set en lugar de make_list)
    User = any(FinalUser),
    Database = any(FinalDatabase),
    SourceHost = any(FinalHost)
    by ProcessSession, LogicalServerName, backend_type, processId
| where SelectCount > 15  // Threshold ajustado: >15 SELECTs en 5 minutos
| extend AnomalyType = "Potential Data Exfiltration"
| project 
    TimeGenerated = LastSeen,
    AnomalyType,
    ServerName = LogicalServerName,
    User,
    Database,
    SourceHost,
    BackendType = backend_type,
    ProcessID = processId,
    SelectCount,
    TimeWindow = strcat(format_datetime(FirstSeen, 'HH:mm:ss'), " - ", format_datetime(LastSeen, 'HH:mm:ss')),
    TablesAccessed = strcat_array(TablesAccessed, ", "),
    SampleQueries = strcat_array(SampleQueries, " ||| ");

suspiciousDataAccess


// ============================================================================
// ANOMAL√çA 2: Operaciones Destructivas Masivas
// ============================================================================
// VERSI√ìN STANDALONE para dashboards RTI (sessionInfo como subquery inline)

let destructiveOperations = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(10m)
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where message has_any ("DELETE", "UPDATE", "TRUNCATE", "DROP TABLE", "DROP DATABASE")
| extend 
    AuditOperation = extract(@"AUDIT: SESSION,\d+,\d+,([A-Z]+),", 1, message),
    AuditStatement = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message),
    TableAffected = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    QueryText = trim('"', extract(@",,,([^<]+)<", 1, message)),
    // Extracci√≥n directa del mensaje AUDIT (algunos logs incluyen user/database/host)
    DirectUser = extract(@"user=([^\s,]+)", 1, message),
    DirectDatabase = extract(@"database=([^\s,]+)", 1, message),
    DirectHost = extract(@"host=([^\s]+)", 1, message)
| where AuditStatement in ("DELETE", "UPDATE", "TRUNCATE", "DROP") 
    or QueryText contains "DROP TABLE" 
    or QueryText contains "DROP DATABASE"
// Correlaci√≥n con sessionInfo (inline) para obtener User/Database/Host
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized" or message contains "connection received"
    | extend 
        UserName = extract(@"user=([^\s,]+)", 1, message),
        DatabaseName = extract(@"database=([^\s,]+)", 1, message),
        ClientHost = extract(@"host=([^\s]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName), Database = any(DatabaseName), SourceHost = any(ClientHost)
        by processId, LogicalServerName
) on processId, LogicalServerName
| extend
    // Priorizar extracci√≥n directa, luego sessionInfo, finalmente "UNKNOWN"
    FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN")),
    FinalDatabase = iff(isnotempty(DirectDatabase), DirectDatabase, iff(isnotempty(Database), Database, "UNKNOWN")),
    FinalHost = iff(isnotempty(DirectHost), DirectHost, iff(isnotempty(SourceHost), SourceHost, "UNKNOWN"))
| summarize 
    OperationCount = count(),
    Operations = make_set(AuditStatement),
    TablesAffected = make_set(TableAffected),
    FirstOccurrence = min(EventProcessedUtcTime),
    LastOccurrence = max(EventProcessedUtcTime),
    SampleMessages = make_set(QueryText, 3),  // Cambio: make_set en lugar de take_any
    User = any(FinalUser),
    Database = any(FinalDatabase),
    SourceHost = any(FinalHost)
    by LogicalServerName, backend_type, bin(EventProcessedUtcTime, 2m)
| where OperationCount > 5  // M√°s de 5 operaciones destructivas en 2 minutos
| where backend_type == "client backend"  // FILTRAR workers DESPU√âS del threshold
| extend AnomalyType = "Mass Destructive Operations"
| project 
    TimeGenerated = LastOccurrence,
    AnomalyType,
    ServerName = LogicalServerName,
    User,
    Database,
    SourceHost,
    BackendType = backend_type,
    OperationCount,
    Operations,
    TablesAffected,
    TimeWindow = strcat(FirstOccurrence, " to ", LastOccurrence),
    SampleMessages;

destructiveOperations


// ============================================================================
// ANOMAL√çA 3: Escalada de Errores Cr√≠ticos
// ============================================================================
// VERSI√ìN STANDALONE para dashboards RTI (sessionInfo como subquery inline)

let errorSpike = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(30m)  // Aumentado de 5m a 30m para troubleshooting
| where category == "PostgreSQLLogs"
| where errorLevel in ("ERROR", "FATAL", "PANIC")
    or (sqlerrcode != "00000" and sqlerrcode != "")
| extend 
    ErrorCategory = case(
        message contains "authentication" or message contains "password", "Authentication Failure",
        message contains "permission denied" or message contains "access denied", "Permission Denied",
        message contains "connection" or message contains "timeout", "Connection Error",
        sqlerrcode startswith "28", "Authorization Error",
        sqlerrcode startswith "42", "Permission Error",
        sqlerrcode startswith "08", "Connection Error",
        sqlerrcode startswith "53", "Resource Error",
        sqlerrcode startswith "57", "Operator Intervention",
        "Other Error"
    ),
    // Extraer User/Database directamente de logs de error (pueden contener esta info)
    DirectUser = extract(@"user=([^\s,]+)", 1, message),
    DirectDatabase = extract(@"database=([^\s,]+)", 1, message),
    DirectHost = extract(@"host=([^\s]+)", 1, message)
// Correlaci√≥n con sessionInfo (inline) para casos donde no est√° en el mensaje de error
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized" or message contains "connection received"
    | extend 
        UserName = extract(@"user=([^\s,]+)", 1, message),
        DatabaseName = extract(@"database=([^\s,]+)", 1, message),
        ClientHost = extract(@"host=([^\s]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName), Database = any(DatabaseName), SourceHost = any(ClientHost)
        by processId, LogicalServerName
) on processId, LogicalServerName
| extend
    FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN")),
    FinalDatabase = iff(isnotempty(DirectDatabase), DirectDatabase, iff(isnotempty(Database), Database, "UNKNOWN")),
    FinalHost = iff(isnotempty(DirectHost), DirectHost, iff(isnotempty(SourceHost), SourceHost, "UNKNOWN"))
| summarize 
    ErrorCount = count(),
    ErrorTypes = make_set(ErrorCategory),
    ErrorCodes = make_set(sqlerrcode),
    FirstError = min(EventProcessedUtcTime),
    LastError = max(EventProcessedUtcTime),
    SampleErrors = make_set(message, 3),  // Cambio: make_set en lugar de take_any
    User = any(FinalUser),
    Database = any(FinalDatabase),
    SourceHost = any(FinalHost)
    by LogicalServerName, backend_type, bin(EventProcessedUtcTime, 1m)
// Eliminado threshold para troubleshooting - muestra todos los errores agrupados
| extend AnomalyType = "Critical Error Spike"
| project 
    TimeGenerated = LastError,
    AnomalyType,
    ServerName = LogicalServerName,
    User,
    Database,
    SourceHost,
    BackendType = backend_type,
    ErrorCount,
    ErrorTypes,
    ErrorCodes,
    TimeWindow = strcat(FirstError, " to ", LastError),
    SampleErrors
| order by ErrorCount desc;  // Ordenar por ErrorCount para ver los picos primero

errorSpike


// ============================================================================
// ============================================================================
//                    üî¥ ADVANCED ANOMALIES (v3)
//              Patterns that Defender/SIEM CANNOT detect
// ============================================================================
// ============================================================================


// ============================================================================
// ANOMAL√çA 4: Escalada de Privilegios (Privilege Escalation)
// ============================================================================
// Detecta secuencias de GRANT/REVOKE/ALTER ROLE sospechosas
// Threshold: >3 operaciones de privilegios en 5 minutos

let privilegeEscalation = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(10m)
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where message has_any ("GRANT", "REVOKE", "ALTER ROLE", "CREATE ROLE", "DROP ROLE")
| extend 
    PrivilegeOp = case(
        message contains "GRANT", "GRANT",
        message contains "REVOKE", "REVOKE",
        message contains "ALTER ROLE", "ALTER ROLE",
        message contains "CREATE ROLE", "CREATE ROLE",
        message contains "DROP ROLE", "DROP ROLE",
        "OTHER"
    ),
    QueryText = trim('"', extract(@",,,([^<]+)<", 1, message)),
    DirectUser = extract(@"user=([^\s,]+)", 1, message)
// Correlaci√≥n para identificar el usuario
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized" or message contains "connection received"
    | extend UserName = extract(@"user=([^\s,]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName) by processId, LogicalServerName
) on processId, LogicalServerName
| extend FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN"))
| where FinalUser != "azuresu"
| summarize 
    PrivilegeOpsCount = count(),
    Operations = make_set(PrivilegeOp),
    FirstOp = min(EventProcessedUtcTime),
    LastOp = max(EventProcessedUtcTime),
    SampleQueries = make_set(QueryText, 3),
    User = any(FinalUser)
    by LogicalServerName, bin(EventProcessedUtcTime, 5m)
| where PrivilegeOpsCount > 3  // M√°s de 3 operaciones de privilegios en 5 minutos
| extend 
    AnomalyType = "Privilege Escalation",
    Severity = case(
        PrivilegeOpsCount > 10, "CRITICAL",
        PrivilegeOpsCount > 5, "HIGH",
        "MEDIUM"
    )
| project 
    TimeGenerated = LastOp,
    AnomalyType,
    Severity,
    ServerName = LogicalServerName,
    User,
    PrivilegeOpsCount,
    Operations,
    TimeWindow = strcat(FirstOp, " to ", LastOp),
    SampleQueries;

privilegeEscalation


// ============================================================================
// ANOMAL√çA 5: Reconocimiento Cross-Schema (Lateral Movement)
// ============================================================================
// Detecta acceso a m√∫ltiples schemas en poco tiempo
// Threshold: >4 schemas diferentes accedidos en 10 minutos

let crossSchemaRecon = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(15m)
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where backend_type == "client backend"
| extend 
    SchemaAccessed = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^\.]+)\.", 1, message),
    TableAccessed = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    DirectUser = extract(@"user=([^\s,]+)", 1, message)
| where isnotempty(SchemaAccessed) or isnotempty(TableAccessed)
| extend SchemaName = iff(isnotempty(SchemaAccessed), SchemaAccessed, 
    extract(@"^([^\.]+)\.", 1, TableAccessed))
| where isnotempty(SchemaName) and SchemaName !in ("pg_catalog", "information_schema", "")
// Correlaci√≥n para usuario
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized"
    | extend UserName = extract(@"user=([^\s,]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName) by processId, LogicalServerName
) on processId, LogicalServerName
| extend FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN"))
| where FinalUser != "azuresu"
| summarize 
    SchemasAccessed = dcount(SchemaName),
    SchemaList = make_set(SchemaName),
    TablesAccessed = dcount(TableAccessed),
    FirstAccess = min(EventProcessedUtcTime),
    LastAccess = max(EventProcessedUtcTime),
    User = any(FinalUser)
    by LogicalServerName, processId, bin(EventProcessedUtcTime, 10m)
| where SchemasAccessed > 4  // M√°s de 4 schemas = movimiento lateral
| extend 
    AnomalyType = "Cross-Schema Reconnaissance",
    Severity = case(
        SchemasAccessed > 8, "CRITICAL",
        SchemasAccessed > 5, "HIGH",
        "MEDIUM"
    )
| project 
    TimeGenerated = LastAccess,
    AnomalyType,
    Severity,
    ServerName = LogicalServerName,
    User,
    SchemasAccessed,
    SchemaList = strcat_array(SchemaList, ", "),
    TablesAccessed,
    TimeWindow = strcat(FirstAccess, " to ", LastAccess);

crossSchemaRecon


// ============================================================================
// ANOMAL√çA 6: Enumeraci√≥n de Schema de Sistema (Deep Scan)
// ============================================================================
// Detecta queries masivas a pg_catalog/information_schema
// Threshold: >10 queries a tablas de sistema en 5 minutos

let deepSchemaEnum = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(10m)
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where backend_type == "client backend"
| extend QueryText = trim('"', extract(@",,,([^<]+)<", 1, message))
| where QueryText contains "pg_catalog" 
    or QueryText contains "information_schema"
    or QueryText contains "pg_tables"
    or QueryText contains "pg_class"
    or QueryText contains "pg_attribute"
    or QueryText contains "pg_proc"
    or QueryText contains "pg_type"
    or QueryText contains "pg_constraint"
    or QueryText contains "pg_roles"
| extend 
    SystemTable = case(
        QueryText contains "pg_tables", "pg_tables",
        QueryText contains "pg_class", "pg_class",
        QueryText contains "pg_attribute", "pg_attribute",
        QueryText contains "pg_proc", "pg_proc",
        QueryText contains "pg_type", "pg_type",
        QueryText contains "pg_constraint", "pg_constraint",
        QueryText contains "pg_roles", "pg_roles",
        QueryText contains "pg_indexes", "pg_indexes",
        QueryText contains "information_schema.tables", "info_tables",
        QueryText contains "information_schema.columns", "info_columns",
        QueryText contains "information_schema.routines", "info_routines",
        "other_system"
    ),
    DirectUser = extract(@"user=([^\s,]+)", 1, message)
// Correlaci√≥n para usuario
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized"
    | extend UserName = extract(@"user=([^\s,]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName) by processId, LogicalServerName
) on processId, LogicalServerName
| extend FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN"))
| where FinalUser != "azuresu"
| summarize 
    SystemTableQueries = count(),
    TablesScanned = make_set(SystemTable),
    UniqueSystemTables = dcount(SystemTable),
    FirstQuery = min(EventProcessedUtcTime),
    LastQuery = max(EventProcessedUtcTime),
    SampleQueries = make_set(QueryText, 3),
    User = any(FinalUser)
    by LogicalServerName, processId, bin(EventProcessedUtcTime, 5m)
| where SystemTableQueries > 10  // M√°s de 10 queries = reconocimiento profundo
| extend 
    AnomalyType = "Deep Schema Enumeration",
    Severity = case(
        SystemTableQueries > 30, "CRITICAL",
        SystemTableQueries > 15, "HIGH",
        "MEDIUM"
    ),
    RiskLevel = iff(UniqueSystemTables > 5, "üî¥ HIGH - Multi-table scan", "üü† MEDIUM")
| project 
    TimeGenerated = LastQuery,
    AnomalyType,
    Severity,
    RiskLevel,
    ServerName = LogicalServerName,
    User,
    SystemTableQueries,
    UniqueSystemTables,
    TablesScanned = strcat_array(TablesScanned, ", "),
    TimeWindow = strcat(FirstQuery, " to ", LastQuery);

deepSchemaEnum


// ============================================================================
// ANOMAL√çA 7: ML Anomaly Detection - Desviaci√≥n de Baseline
// ============================================================================
// Usa series_decompose_anomalies() para detectar desviaci√≥n del patr√≥n normal
// Requiere tabla postgres_activity_metrics configurada

let mlAnomalyDetection = 
postgres_activity_metrics
| where Timestamp >= ago(7d)
| where isnotempty(ServerName)
| make-series ActivitySeries = sum(ActivityCount) default=0 
    on Timestamp step 5m 
    by ServerName
| extend (anomalies, score, baseline) = 
    series_decompose_anomalies(ActivitySeries, 1.5, -1, 'linefit')
| mv-expand Timestamp to typeof(datetime), 
    ActivitySeries to typeof(long), 
    anomalies to typeof(int), 
    score to typeof(double), 
    baseline to typeof(double)
| where anomalies != 0  // Solo anomal√≠as (1 = alto, -1 = bajo)
| where Timestamp >= ago(1h)  // Solo √∫ltimas anomal√≠as
| extend 
    AnomalyType = "ML Baseline Deviation",
    AnomalyDirection = iff(anomalies > 0, "üìà Above Normal", "üìâ Below Normal"),
    Severity = case(
        abs(score) > 3.0, "CRITICAL",
        abs(score) > 2.0, "HIGH",
        "MEDIUM"
    )
| project 
    TimeGenerated = Timestamp,
    AnomalyType,
    AnomalyDirection,
    Severity,
    ServerName,
    ActivityCount = ActivitySeries,
    ExpectedBaseline = round(baseline, 0),
    DeviationScore = round(score, 2)
| order by abs(DeviationScore) desc
| take 20;

mlAnomalyDetection


// ============================================================================
// DASHBOARD PRINCIPAL: Todas las Anomal√≠as (Incluyendo Avanzadas)
// ============================================================================

union
    (suspiciousDataAccess),
    (destructiveOperations),
    (errorSpike),
    (privilegeEscalation),
    (crossSchemaRecon),
    (deepSchemaEnum)
| order by TimeGenerated desc
| take 100;


// ============================================================================
// DASHBOARD TILES - PANELES
// ============================================================================

// ----------------------------------------------------------------------------
// TILE 1: Actividad General por Servidor (√∫ltima hora)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(1h)
| where isnotempty(LogicalServerName) and trim(" ", LogicalServerName) != ""
| summarize 
    TotalEvents = count(),
    Errors = countif(errorLevel in ("ERROR", "FATAL", "PANIC")),
    Warnings = countif(errorLevel == "WARNING"),
    AuditLogs = countif(message contains "AUDIT:")
    by LogicalServerName, bin(EventProcessedUtcTime, 2m)
| render timechart


// ----------------------------------------------------------------------------
// TILE 2: Distribuci√≥n de Tipos de Operaciones AUDIT (√∫ltimas 6h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(6h)
| where message contains "AUDIT:"
| extend AuditStatement = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message)
| where isnotempty(AuditStatement)
| summarize Count = count() by AuditStatement
| order by Count desc
| take 10
| render piechart;


// ----------------------------------------------------------------------------
// TILE 3: Top 15 Tablas M√°s Accedidas (AUDIT)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(6h)
| where message contains "AUDIT:"
| extend 
    ObjectType = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    ObjectName = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,[^,]*,([^,<]*)", 1, message)
| where isnotempty(ObjectName) and ObjectName != ""
| summarize 
    AccessCount = count(),
    LastAccess = max(EventProcessedUtcTime),
    ObjectTypes = make_set(ObjectType, 5)  // Capturar tipos de objeto accedidos
    by ObjectName, LogicalServerName
| extend ObjectTypesDisplay = strcat_array(ObjectTypes, ", ")
| top 15 by AccessCount desc
| project ObjectName, ObjectTypesDisplay, LogicalServerName, AccessCount, LastAccess;


// ----------------------------------------------------------------------------
// TILE 4: Timeline de Operaciones AUDIT por Tipo (√∫ltima hora)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(1h)
| where message contains "AUDIT:"
| extend OperationType = case(
    message contains ",READ," or message contains ",SELECT,", "SELECT",
    message contains ",WRITE," or message contains ",UPDATE,", "WRITE",
    message contains ",DELETE,", "DELETE",
    message contains ",INSERT,", "INSERT",
    message contains ",DDL,", "DDL",
    message contains ",MISC,", "MISC",
    "OTHER"
)
| summarize Count = count() by OperationType, bin(EventProcessedUtcTime, 2m)
| render timechart;


// ----------------------------------------------------------------------------
// TILE 5: Errores por Categor√≠a (√∫ltimas 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where errorLevel in ("ERROR", "FATAL", "PANIC")
| extend ErrorCategory = case(
    message contains "authentication", "Auth Errors",
    message contains "permission", "Permission Errors",
    message contains "connection", "Connection Errors",
    sqlerrcode startswith "28", "Auth Errors",
    sqlerrcode startswith "42", "Permission Errors",
    sqlerrcode startswith "08", "Connection Errors",
    sqlerrcode startswith "53", "Resource Errors",
    "Other Errors"
)
| summarize Count = count() by ErrorCategory, bin(EventProcessedUtcTime, 30m)
| render areachart;


// ----------------------------------------------------------------------------
// TILE 6: Actividad por Backend Type (√∫ltima hora)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(1h)
| where message contains "AUDIT:"
| summarize 
    TotalLogs = count(),
    Errors = countif(errorLevel in ("ERROR", "FATAL"))
    by backend_type, bin(EventProcessedUtcTime, 5m)
| render timechart;


// ----------------------------------------------------------------------------
// TILE 7: Operaciones Destructivas Recientes (√∫ltimas 6h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(6h)
| where message contains "AUDIT:"
| where message has_any ("DELETE", "UPDATE", "TRUNCATE", "DROP")
| extend 
    Operation = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message),
    TableAffected = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    QueryText = trim('"', extract(@",,,([^<]+)<", 1, message))
| where isnotempty(Operation)
| project 
    EventProcessedUtcTime,
    LogicalServerName,
    Operation,
    TableAffected,
    backend_type,
    QueryText = substring(QueryText, 0, 80)
| order by EventProcessedUtcTime desc
| take 50;


// ----------------------------------------------------------------------------
// TILE 8: Top C√≥digos de Error (√∫ltimas 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where sqlerrcode != "00000" and sqlerrcode != ""
| summarize 
    Count = count(),
    LastOccurrence = max(EventProcessedUtcTime)
    by sqlerrcode, errorLevel
| order by Count desc
| take 15
| extend ErrorDescription = case(
    sqlerrcode startswith "28", "Auth/Authorization",
    sqlerrcode startswith "42", "Syntax/Permission",
    sqlerrcode startswith "08", "Connection Exception",
    sqlerrcode startswith "53", "Insufficient Resources",
    sqlerrcode startswith "57", "Operator Intervention",
    sqlerrcode startswith "23", "Integrity Violation",
    "Other"
)
| project sqlerrcode, ErrorDescription, errorLevel, Count, LastOccurrence;


// ----------------------------------------------------------------------------
// TILE 9: TOP 10 USUARIOS por Actividad (√∫ltimas 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| extend UserName = trim('"', extract(@"user=([^\s,]+)", 1, message))
| where isnotempty(UserName)
| summarize 
    TotalActivity = count(),
    AuditLogs = countif(message contains "AUDIT:"),
    Connections = countif(message contains "connection authorized"),
    Errors = countif(errorLevel in ("ERROR", "FATAL")),
    Databases = dcount(trim('"', extract(@"database=([^\s,]+)", 1, message))),
    LastActivity = max(EventProcessedUtcTime)
    by UserName
| top 10 by TotalActivity desc
| project UserName, TotalActivity, AuditLogs, Connections, Errors, Databases, LastActivity;


// ----------------------------------------------------------------------------
// TILE 10: TOP 10 HOSTS/IPs por Conexiones (√∫ltimas 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| extend 
    ClientHost = extract(@"host=([^\s]+)", 1, message),
    UserName = extract(@"user=([^\s,]+)", 1, message)
| where isnotempty(ClientHost)
| summarize 
    TotalConnections = count(),
    UniqueUsers = dcount(UserName),
    Users = make_set(UserName, 10),  // Lista de usuarios que se conectan desde este host
    Errors = countif(errorLevel in ("ERROR", "FATAL")),
    FirstSeen = min(EventProcessedUtcTime),
    LastSeen = max(EventProcessedUtcTime)
    by ClientHost
| extend 
    UsersDisplay = strcat_array(Users, ", "),  // Convertir array a string legible
    ErrorRate = round((todouble(Errors) / TotalConnections) * 100, 2),
    Riesgo = case(
        round((todouble(Errors) / TotalConnections) * 100, 2) > 20, "HIGH",
        round((todouble(Errors) / TotalConnections) * 100, 2) > 5, "MEDIUM",
        "LOW"
    )
| top 10 by TotalConnections desc
| project ClientHost, TotalConnections, UniqueUsers, UsersDisplay, Errors, ErrorRate, Riesgo, FirstSeen, LastSeen;


// ----------------------------------------------------------------------------
// TILE 11: Heat Map User + Database (√∫ltimas 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where message contains "AUDIT:" or message contains "connection authorized"
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    DatabaseName = extract(@"database=([^\s,]+)", 1, message)
| where isnotempty(UserName) and isnotempty(DatabaseName)
| summarize 
    ActivityCount = count(),
    AuditLogs = countif(message contains "AUDIT:"),
    LastActivity = max(EventProcessedUtcTime)
    by UserName, DatabaseName
| where ActivityCount > 10
| order by ActivityCount desc
| take 50
| project UserName, DatabaseName, ActivityCount, AuditLogs, LastActivity;


// ----------------------------------------------------------------------------
// TILE 12: Fallos de Autenticaci√≥n por Usuario/Host (√∫ltimas 24h)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where message contains "authentication failed" 
    or message contains "password authentication failed"
    or sqlerrcode == "28P01"
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    ClientHost = extract(@"host=([^\s]+)", 1, message),
    DatabaseName = extract(@"database=([^\s,]+)", 1, message)
| summarize 
    FailedAttempts = count(),
    FirstAttempt = min(EventProcessedUtcTime),
    LastAttempt = max(EventProcessedUtcTime),
    Databases = make_set(DatabaseName)
    by UserName, ClientHost
| extend 
    ThreatLevel = case(
        FailedAttempts > 20, "CRITICAL",
        FailedAttempts > 10, "HIGH",
        FailedAttempts > 5, "MEDIUM",
        "LOW"
    )
| order by FailedAttempts desc
| take 20
| project UserName, ClientHost, FailedAttempts, ThreatLevel, Databases, FirstAttempt, LastAttempt;


// ============================================================================
// QUERIES DE AN√ÅLISIS AVANZADO
// ============================================================================

// ----------------------------------------------------------------------------
// Detecci√≥n de Acceso a Tablas del Sistema (Reconocimiento)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where message contains "AUDIT:"
| extend QueryText = trim('"', extract(@",,,([^<]+)<", 1, message))
| where QueryText contains "pg_catalog" 
    or QueryText contains "information_schema"
    or QueryText contains "pg_database"
    or QueryText contains "pg_stat"
    or QueryText contains "pg_tables"
| extend 
    AuditOperation = extract(@"AUDIT: SESSION,\d+,\d+,([A-Z]+),", 1, message),
    AuditStatement = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message),
    DirectUser = trim('"', extract(@"user=([^\s,]+)", 1, message))
// Correlaci√≥n para identificar el usuario (inline)
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized" or message contains "connection received"
    | extend 
        UserName = trim('"', extract(@"user=([^\s,]+)", 1, message)),
        DatabaseName = extract(@"database=([^\s,]+)", 1, message),
        ClientHost = extract(@"host=([^\s]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName), Database = any(DatabaseName), SourceHost = any(ClientHost)
        by processId, LogicalServerName
) on processId, LogicalServerName
| extend FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN"))
| where FinalUser != "azuresu"  // Filtrar usuario de monitoreo de la plataforma
| summarize 
    AccessCount = count(),
    Operations = make_set(AuditStatement),
    FirstAccess = min(EventProcessedUtcTime),
    LastAccess = max(EventProcessedUtcTime),
    SampleQueries = take_any(QueryText, 3),
    User = any(FinalUser),
    SourceHost = any(SourceHost)
    by LogicalServerName, backend_type, bin(EventProcessedUtcTime, 1h)
| where AccessCount > 10
| extend SuspicionLevel = case(
    AccessCount > 50, "üî¥ High",
    AccessCount > 20, "üü† Medium",
    "üü¢ Low"
)
| project 
    LastAccess,
    LogicalServerName,
    User,
    SourceHost = iff(isempty(SourceHost), "UNKNOWN", SourceHost),
    AccessCount,
    SuspicionLevel,
    Operations,
    FirstAccess,
    SampleQueries
| order by AccessCount desc;


// ----------------------------------------------------------------------------
// An√°lisis de Patrones de Acceso por Tabla (Read vs Write)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(7d)
| where message contains "AUDIT:"
| extend 
    Operation = extract(@"AUDIT: SESSION,\d+,\d+,([A-Z]+),", 1, message),
    Statement = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message),
    Table = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message)
| where isnotempty(Table) and Table != ""
| summarize 
    TotalAccess = count(),
    Reads = countif(Operation == "READ" or Statement == "SELECT"),
    Writes = countif(Operation == "WRITE" or Statement in ("INSERT", "UPDATE", "DELETE")),
    DDL = countif(Operation == "DDL"),
    LastAccess = max(EventProcessedUtcTime)
    by Table, LogicalServerName
| extend ReadWriteRatio = iff(Writes > 0, round(todouble(Reads) / todouble(Writes), 2), 999.0)
| order by TotalAccess desc
| take 30;


// ----------------------------------------------------------------------------
// Sesiones de Larga Duraci√≥n (Posible Sesi√≥n Comprometida)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| summarize 
    FirstActivity = min(EventProcessedUtcTime),
    LastActivity = max(EventProcessedUtcTime),
    TotalEvents = count(),
    AuditEvents = countif(message contains "AUDIT:"),
    ErrorCount = countif(errorLevel in ("ERROR", "FATAL"))
    by processId, LogicalServerName, backend_type
| extend SessionDuration = datetime_diff('minute', LastActivity, FirstActivity)
| where SessionDuration > 120  // Sesiones de m√°s de 2 horas
| order by SessionDuration desc
| extend Alert = case(
    SessionDuration > 480, "üî¥ Very Long Session (>8h)",
    SessionDuration > 240, "üü† Long Session (>4h)",
    "üü° Medium Session (>2h)"
)
| project 
    processId,
    LogicalServerName,
    backend_type,
    SessionDurationHours = round(todouble(SessionDuration) / 60.0, 2),
    TotalEvents,
    AuditEvents,
    ErrorCount,
    FirstActivity,
    LastActivity,
    Alert;


// ----------------------------------------------------------------------------
// Baseline de Actividad por Hora del D√≠a (√∫ltimos 7 d√≠as)
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(7d)
| where isnotempty(LogicalServerName) and trim(" ", LogicalServerName) != ""
| extend HourOfDay = hourofday(EventProcessedUtcTime)
| summarize 
    AvgEventsPerHour = count() / 7,
    MaxEvents = max(bin(EventProcessedUtcTime, 1h)),
    MinEvents = min(bin(EventProcessedUtcTime, 1h))
    by HourOfDay, LogicalServerName
| order by HourOfDay asc
| render columnchart;


// ============================================================================
// QUERIES DE VALIDACI√ìN
// ============================================================================

// ----------------------------------------------------------------------------
// Verificar que llegan datos recientes
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| summarize 
    LastEvent = max(EventProcessedUtcTime),
    FirstEvent = min(EventProcessedUtcTime),
    TotalEvents = count(),
    TimeRange = datetime_diff('day', max(EventProcessedUtcTime), min(EventProcessedUtcTime))
| extend 
    Status = iff(datetime_diff('minute', now(), LastEvent) < 5, "‚úÖ Fresh data", "‚ö†Ô∏è Stale data"),
    LatencyMinutes = datetime_diff('minute', now(), LastEvent);


// ----------------------------------------------------------------------------
// Cobertura de AUDIT Logs
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(1h)
| summarize 
    TotalLogs = count(),
    AuditLogs = countif(message contains "AUDIT:"),
    ErrorLogs = countif(errorLevel in ("ERROR", "FATAL", "PANIC")),
    WarningLogs = countif(errorLevel == "WARNING")
    by LogicalServerName
| extend 
    AuditCoverage = round((todouble(AuditLogs) / TotalLogs) * 100, 2),
    ErrorRate = round((todouble(ErrorLogs) / TotalLogs) * 100, 2);


// ----------------------------------------------------------------------------
// Distribuci√≥n de Backend Types
// ----------------------------------------------------------------------------

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| summarize Count = count() by backend_type
| order by Count desc;
