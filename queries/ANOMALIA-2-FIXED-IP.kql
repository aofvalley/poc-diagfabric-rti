// ============================================================================
// ANOMALÍA 2 - FIXED: Operaciones Destructivas con IPs
// ============================================================================
// PROBLEMA: sessionInfo busca en 24h pero la query busca en 10m
// SOLUCIÓN: Alinear ventanas de tiempo O expandir sessionInfo
// ============================================================================

// OPCIÓN 1: sessionInfo con ventana amplia (RECOMENDADO)
// ============================================================================
// Busca conexiones en las últimas 24h (cubre todas las sesiones activas)

let sessionInfo = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)  // ✅ Ventana amplia para capturar conexiones antiguas
| where message contains "connection authorized" or message contains "connection received"
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    DatabaseName = extract(@"database=([^\s,]+)", 1, message),
    ClientHost = extract(@"host=([^\s]+)", 1, message)
| where isnotempty(UserName)
| summarize User = any(UserName), Database = any(DatabaseName), SourceHost = any(ClientHost)
    by processId, LogicalServerName;

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(10m)  // Solo logs AUDIT recientes
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where message has_any ("DELETE", "UPDATE", "TRUNCATE", "DROP TABLE", "DROP DATABASE")
| extend 
    AuditOperation = extract(@"AUDIT: SESSION,\d+,\d+,([A-Z]+),", 1, message),
    AuditStatement = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message),
    TableAffected = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    QueryText = trim('"', extract(@",,,([^<]+)<", 1, message))
| where AuditStatement in ("DELETE", "UPDATE", "TRUNCATE", "DROP") 
    or QueryText contains "DROP TABLE" 
    or QueryText contains "DROP DATABASE"
// JOIN con sessionInfo
| join kind=leftouter sessionInfo on processId, LogicalServerName
| summarize 
    OperationCount = count(),
    Operations = make_set(AuditStatement),
    TablesAffected = make_set(TableAffected),
    FirstOccurrence = min(EventProcessedUtcTime),
    LastOccurrence = max(EventProcessedUtcTime),
    SampleMessages = make_set(QueryText, 3),  // ✅ CORREGIDO: make_set en vez de take_any
    User = any(User),
    Database = any(Database),
    SourceHost = any(SourceHost)
    by LogicalServerName, backend_type, bin(EventProcessedUtcTime, 2m)
| where OperationCount > 5
| where backend_type == "client backend"  // ✅ Filtrar DESPUÉS del threshold
| project 
    TimeGenerated = LastOccurrence,
    AnomalyType = "Mass Destructive Operations",
    ServerName = LogicalServerName,
    User = iff(isempty(User), "UNKNOWN", User),
    Database = iff(isempty(Database), "UNKNOWN", Database),
    SourceHost = iff(isempty(SourceHost), "UNKNOWN", SourceHost),
    BackendType = backend_type,
    OperationCount,
    Operations = strcat_array(Operations, ", "),  // ✅ Formatear array
    TablesAffected = strcat_array(TablesAffected, ", "),
    TimeWindow = strcat(FirstOccurrence, " to ", LastOccurrence),
    SampleMessages = strcat_array(SampleMessages, " ||| ")  // ✅ Formatear array
| order by OperationCount desc;


// ============================================================================
// OPCIÓN 2: Ventanas alineadas (Para alertas en tiempo real)
// ============================================================================
// Si quieres detectar anomalías MUY recientes (últimos 10 min), usa esta versión
// VENTAJA: Más rápida, solo procesa últimos 10 min
// DESVENTAJA: Solo funciona si la conexión también es de los últimos 10 min

let sessionInfo = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(10m)  // ⚠️ Misma ventana que AUDIT logs
| where message contains "connection authorized" or message contains "connection received"
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    DatabaseName = extract(@"database=([^\s,]+)", 1, message),
    ClientHost = extract(@"host=([^\s]+)", 1, message)
| where isnotempty(UserName)
| summarize User = any(UserName), Database = any(DatabaseName), SourceHost = any(ClientHost)
    by processId, LogicalServerName;

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(10m)
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where message has_any ("DELETE", "UPDATE", "TRUNCATE", "DROP TABLE", "DROP DATABASE")
| extend 
    AuditOperation = extract(@"AUDIT: SESSION,\d+,\d+,([A-Z]+),", 1, message),
    AuditStatement = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message),
    TableAffected = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    QueryText = trim('"', extract(@",,,([^<]+)<", 1, message))
| where AuditStatement in ("DELETE", "UPDATE", "TRUNCATE", "DROP") 
    or QueryText contains "DROP TABLE" 
    or QueryText contains "DROP DATABASE"
| join kind=leftouter sessionInfo on processId, LogicalServerName
| summarize 
    OperationCount = count(),
    Operations = make_set(AuditStatement),
    TablesAffected = make_set(TableAffected),
    FirstOccurrence = min(EventProcessedUtcTime),
    LastOccurrence = max(EventProcessedUtcTime),
    SampleMessages = make_set(QueryText, 3),
    User = any(User),
    Database = any(Database),
    SourceHost = any(SourceHost)
    by LogicalServerName, backend_type, bin(EventProcessedUtcTime, 2m)
| where OperationCount > 5
| where backend_type == "client backend"
| project 
    TimeGenerated = LastOccurrence,
    AnomalyType = "Mass Destructive Operations",
    ServerName = LogicalServerName,
    User = iff(isempty(User), "UNKNOWN", User),
    Database = iff(isempty(Database), "UNKNOWN", Database),
    SourceHost = iff(isempty(SourceHost), "UNKNOWN", SourceHost),
    BackendType = backend_type,
    OperationCount,
    Operations = strcat_array(Operations, ", "),
    TablesAffected = strcat_array(TablesAffected, ", "),
    TimeWindow = strcat(FirstOccurrence, " to ", LastOccurrence),
    SampleMessages = strcat_array(SampleMessages, " ||| ")
| order by OperationCount desc;


// ============================================================================
// OPCIÓN 3: DIAGNÓSTICO - Ver qué processIds tienen/no tienen info
// ============================================================================

// Ver processIds de AUDIT logs (últimos 10 min)
let auditProcessIds = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(10m)
| where message contains "AUDIT:"
| distinct processId, LogicalServerName;

// Ver processIds con información de conexión (últimas 24h)
let connectionProcessIds = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| where message contains "connection authorized" or message contains "connection received"
| extend 
    UserName = extract(@"user=([^\s,]+)", 1, message),
    ClientHost = extract(@"host=([^\s]+)", 1, message)
| where isnotempty(UserName)
| distinct processId, LogicalServerName, UserName, ClientHost;

// Comparar: ¿Qué processIds de AUDIT NO tienen info de conexión?
auditProcessIds
| join kind=leftanti connectionProcessIds on processId, LogicalServerName
| project 
    processId, 
    LogicalServerName,
    Status = "❌ AUDIT processId SIN info de conexión (por eso SourceHost = UNKNOWN)"
| union (
    auditProcessIds
    | join kind=inner connectionProcessIds on processId, LogicalServerName
    | project 
        processId, 
        LogicalServerName,
        UserName,
        ClientHost,
        Status = "✅ AUDIT processId CON info de conexión"
);


// ============================================================================
// OPCIÓN 4: Fallback - Extraer IP directamente del mensaje AUDIT
// ============================================================================
// Algunos logs AUDIT incluyen user/database en el mensaje
// Aunque no es común, podemos intentar extraerlo

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(10m)
| where category == "PostgreSQLLogs"
| where message contains "AUDIT:"
| where message has_any ("DELETE", "UPDATE", "TRUNCATE", "DROP TABLE", "DROP DATABASE")
| extend 
    AuditStatement = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,([A-Z ]+),", 1, message),
    TableAffected = extract(@"AUDIT: SESSION,\d+,\d+,[A-Z]+,[A-Z ]+,([^,]*),", 1, message),
    QueryText = trim('"', extract(@",,,([^<]+)<", 1, message)),
    // ✅ NUEVO: Intentar extraer user/database del mensaje AUDIT directamente
    DirectUser = extract(@"user=([^\s,]+)", 1, message),
    DirectDatabase = extract(@"database=([^\s,]+)", 1, message),
    DirectHost = extract(@"host=([^\s]+)", 1, message)
| where AuditStatement in ("DELETE", "UPDATE", "TRUNCATE", "DROP") 
    or QueryText contains "DROP TABLE" 
    or QueryText contains "DROP DATABASE"
// JOIN para obtener info de sessionInfo
| join kind=leftouter (
    bronze_pssql_alllogs_nometrics
    | where EventProcessedUtcTime >= ago(24h)
    | where message contains "connection authorized" or message contains "connection received"
    | extend 
        UserName = extract(@"user=([^\s,]+)", 1, message),
        DatabaseName = extract(@"database=([^\s,]+)", 1, message),
        ClientHost = extract(@"host=([^\s]+)", 1, message)
    | where isnotempty(UserName)
    | summarize User = any(UserName), Database = any(DatabaseName), SourceHost = any(ClientHost)
        by processId, LogicalServerName
) on processId, LogicalServerName
| extend
    // ✅ PRIORIZAR: Si DirectUser existe, usarlo; si no, usar User de sessionInfo
    FinalUser = iff(isnotempty(DirectUser), DirectUser, iff(isnotempty(User), User, "UNKNOWN")),
    FinalDatabase = iff(isnotempty(DirectDatabase), DirectDatabase, iff(isnotempty(Database), Database, "UNKNOWN")),
    FinalHost = iff(isnotempty(DirectHost), DirectHost, iff(isnotempty(SourceHost), SourceHost, "UNKNOWN"))
| summarize 
    OperationCount = count(),
    Operations = make_set(AuditStatement),
    TablesAffected = make_set(TableAffected),
    FirstOccurrence = min(EventProcessedUtcTime),
    LastOccurrence = max(EventProcessedUtcTime),
    SampleMessages = make_set(QueryText, 3),
    User = any(FinalUser),
    Database = any(FinalDatabase),
    SourceHost = any(FinalHost)
    by LogicalServerName, backend_type, bin(EventProcessedUtcTime, 2m)
| where OperationCount > 5
| where backend_type == "client backend"
| project 
    TimeGenerated = LastOccurrence,
    AnomalyType = "Mass Destructive Operations",
    ServerName = LogicalServerName,
    User,
    Database,
    SourceHost,
    BackendType = backend_type,
    OperationCount,
    Operations = strcat_array(Operations, ", "),
    TablesAffected = strcat_array(TablesAffected, ", "),
    TimeWindow = strcat(FirstOccurrence, " to ", LastOccurrence),
    SampleMessages = strcat_array(SampleMessages, " ||| ")
| order by OperationCount desc;
