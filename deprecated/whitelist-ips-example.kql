// ============================================================================
// QUERY DE EJEMPLO: Whitelist de IPs Conocidas
// ============================================================================
// Usar esta tabla para reducir falsos positivos
// ============================================================================

// Crear tabla de IPs conocidas
.create table KnownIPs (
    IPAddress: string,
    Description: string,
    Location: string,
    Owner: string,
    IsTrusted: bool,
    AddedDate: datetime,
    AddedBy: string,
    Notes: string
)

// Insertar IPs de ejemplo (MODIFICAR CON TUS IPs REALES)
.ingest inline into table KnownIPs <|
192.168.1.100,Corporate VPN Gateway,London Office,IT Team,true,2025-11-20,admin,VPN principal de oficina
10.0.0.50,Admin Workstation,Datacenter,DBA Team,true,2025-11-20,admin,Estaci√≥n de DBAs
172.16.0.10,Application Server,Azure West Europe,DevOps,true,2025-11-20,admin,Servidor de aplicaci√≥n principal
10.1.1.5,Monitoring System,Azure UK South,SRE Team,true,2025-11-20,admin,Prometheus/Grafana monitoring
192.168.2.25,Backup Server,On-Prem,Backup Team,true,2025-11-20,admin,Sistema de backups automatizados


// ============================================================================
// QUERY MODIFICADA: Data Exfiltration con Whitelist
// ============================================================================

let knownIPs = KnownIPs | where IsTrusted == true | project IPAddress;

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(5m)
| where category == "PostgreSQLLogs"
| where message contains "SELECT" 
    or message contains "COPY" 
    or message contains "pg_dump"
    or message contains "\\copy"
| extend clientIP = extract(@"from (\d+\.\d+\.\d+\.\d+)", 1, message)
| where isnotempty(clientIP)
| where clientIP !in (knownIPs)  // ‚¨ÖÔ∏è EXCLUIR IPs conocidas
| summarize 
    QueryCount = count(),
    FirstSeen = min(EventProcessedUtcTime),
    LastSeen = max(EventProcessedUtcTime),
    SampleQueries = take_any(message, 3)
    by clientIP, LogicalServerName, bin(EventProcessedUtcTime, 1m)
| where QueryCount > 10
| extend AnomalyType = "Potential Data Exfiltration"
| project 
    TimeGenerated = LastSeen,
    AnomalyType,
    ServerName = LogicalServerName,
    SourceIP = clientIP,
    QueryCount,
    TimeWindow = strcat(FirstSeen, " to ", LastSeen),
    SampleQueries;


// ============================================================================
// QUERY: Enriquecimiento de Alertas con Contexto de IP
// ============================================================================

let suspiciousDataAccess = 
bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(5m)
| where message contains "SELECT"
| extend clientIP = extract(@"from (\d+\.\d+\.\d+\.\d+)", 1, message)
| where isnotempty(clientIP)
| summarize QueryCount = count() by clientIP, LogicalServerName, bin(EventProcessedUtcTime, 1m)
| where QueryCount > 10;

suspiciousDataAccess
| join kind=leftouter (KnownIPs) on $left.clientIP == $right.IPAddress
| extend 
    IpTrustStatus = case(
        IsTrusted == true, "‚úÖ Trusted IP",
        isempty(IPAddress), "‚ö†Ô∏è Unknown IP",
        IsTrusted == false, "üö´ Untrusted IP",
        "‚ùì Unclassified"
    ),
    IpOwner = iff(isempty(Owner), "Unknown", Owner),
    IpLocation = iff(isempty(Location), "Unknown", Location)
| project 
    EventProcessedUtcTime,
    ServerName = LogicalServerName,
    SourceIP = clientIP,
    QueryCount,
    IpTrustStatus,
    IpOwner,
    IpLocation,
    Notes;


// ============================================================================
// MANAGEMENT QUERIES: Gesti√≥n de Whitelist
// ============================================================================

// A√±adir nueva IP conocida
.ingest inline into table KnownIPs <|
203.0.113.100,New Development Server,Azure UK South,DevOps,true,2025-11-20,dba_user,Servidor reci√©n provisionado

// Ver todas las IPs conocidas
KnownIPs
| order by AddedDate desc

// Actualizar IP (marcar como no confiable)
.append KnownIPs <|
print 
    IPAddress = "192.168.1.100",
    Description = "Corporate VPN Gateway",
    Location = "London Office",
    Owner = "IT Team",
    IsTrusted = false,  // ‚¨ÖÔ∏è Cambiar a false
    AddedDate = now(),
    AddedBy = "security_team",
    Notes = "Temporary block due to suspicious activity"

// Eliminar IP de la whitelist (no recomendado, mejor marcar IsTrusted=false)
.drop table KnownIPs records where IPAddress == "203.0.113.100"

// Ver estad√≠sticas de whitelist
KnownIPs
| summarize 
    TotalIPs = count(),
    TrustedIPs = countif(IsTrusted == true),
    UntrustedIPs = countif(IsTrusted == false)
| extend TrustPercentage = round((todouble(TrustedIPs) / TotalIPs) * 100, 2)


// ============================================================================
// QUERY: Auditor√≠a de Acceso desde IPs No Conocidas (√∫ltimas 24h)
// ============================================================================

let knownIPs = KnownIPs | where IsTrusted == true | project IPAddress;

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(24h)
| extend clientIP = extract(@"from (\d+\.\d+\.\d+\.\d+)", 1, message)
| where isnotempty(clientIP)
| where clientIP !in (knownIPs)
| summarize 
    FirstSeen = min(EventProcessedUtcTime),
    LastSeen = max(EventProcessedUtcTime),
    TotalConnections = count(),
    Errors = countif(errorLevel in ("ERROR", "FATAL")),
    DistinctOperations = dcount(operationName),
    SampleMessages = take_any(message, 2)
    by clientIP, LogicalServerName
| order by TotalConnections desc
| extend RiskScore = case(
    Errors > 10, "üî¥ High Risk",
    TotalConnections > 100, "üü† Medium Risk",
    "üü¢ Low Risk"
)
| project 
    clientIP,
    ServerName = LogicalServerName,
    TotalConnections,
    Errors,
    RiskScore,
    FirstSeen,
    LastSeen,
    SampleMessages;


// ============================================================================
// QUERY: Recomendaciones de IPs para Whitelist
// ============================================================================
// Identifica IPs que aparecen frecuentemente sin errores (candidatas a whitelist)

let knownIPs = KnownIPs | project IPAddress;

bronze_pssql_alllogs_nometrics
| where EventProcessedUtcTime >= ago(7d)
| extend clientIP = extract(@"from (\d+\.\d+\.\d+\.\d+)", 1, message)
| where isnotempty(clientIP)
| where clientIP !in (knownIPs)
| summarize 
    TotalConnections = count(),
    ErrorRate = countif(errorLevel in ("ERROR", "FATAL")) * 100.0 / count(),
    FirstSeen = min(EventProcessedUtcTime),
    LastSeen = max(EventProcessedUtcTime),
    DaysActive = datetime_diff('day', max(EventProcessedUtcTime), min(EventProcessedUtcTime)) + 1
    by clientIP
| where TotalConnections > 100  // IPs con mucha actividad
| where ErrorRate < 1.0  // Tasa de error baja (<1%)
| where DaysActive >= 3  // Al menos 3 d√≠as de actividad
| order by TotalConnections desc
| extend Recommendation = "‚úÖ Consider adding to whitelist"
| project 
    clientIP,
    TotalConnections,
    ErrorRate = round(ErrorRate, 2),
    DaysActive,
    FirstSeen,
    LastSeen,
    Recommendation;
